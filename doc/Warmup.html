<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Binary.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Lists" rel="Chapter" href="Lists.html">
<link title="Arithmetic" rel="Chapter" href="Arithmetic.html">
<link title="Trees" rel="Chapter" href="Trees.html">
<link title="Binary" rel="Chapter" href="Binary.html">
<link title="Warmup" rel="Chapter" href="Warmup.html"><title>Warmup</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Binary.html" title="Binary">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Warmup.html">Warmup</a></h1>

<pre><span class="keyword">module</span> Warmup: <code class="code"><span class="keyword">sig</span></code> <a href="Warmup.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
This module contains a series of warmup exercises with the <code class="code"><span class="constructor">List</span>.fold_left</code>
    and <code class="code"><span class="constructor">List</span>.fold_right</code> functions. These exercises are intended to give
    familiarity with the basic principles of folding, a ubiquitous technique in
    functional programming.<br>
</div>
<hr width="100%">

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type">int list -> int</code></pre><div class="info ">
The <code class="code">sum</code> function returns the sum of the elements in a given list. More
    precisely, <code class="code">sum [x0; ... ; xn] = x0 + ... + xn</code>.<br>
</div>

<pre><span id="VALrev"><span class="keyword">val</span> rev</span> : <code class="type">'a list -> 'a list</code></pre><div class="info ">
The <code class="code">rev</code> is an alias for the <code class="code"><span class="constructor">List</span>.rev</code> function which reverses a list.
    To expand on the specification in the
    <a href=" http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html"> official
    OCaml List module documentation</a>, we should have
    <pre class="codepre"><code class="code">max2&nbsp;[x0;&nbsp;...&nbsp;;&nbsp;xn]&nbsp;=&nbsp;[xn;&nbsp;...&nbsp;;&nbsp;x0]</code></pre><br>
</div>

<pre><span id="VALmax2"><span class="keyword">val</span> max2</span> : <code class="type">'a list -> 'a</code></pre><div class="info ">
The <code class="code">max2</code> function should return the second-greatest element in an
    <code class="code"><span class="keywordsign">'</span>a list</code> with respect to the canonical ordering given by
    <code class="code"><span class="constructor">Pervasives</span>.compare</code>. Your implementation should satisfy the following
    identity: <pre class="codepre"><code class="code"><span class="constructor">List</span>.length&nbsp;(<span class="constructor">List</span>.filter&nbsp;((&gt;)&nbsp;(max2&nbsp;xs)))&nbsp;=&nbsp;1</code></pre> for all input
    lists <code class="code">xs</code>.<br>
</div>

<pre><span id="VALall_pairs"><span class="keyword">val</span> all_pairs</span> : <code class="type">'a list -> ('a * 'a) list</code></pre><div class="info ">
<code class="code">all_pairs xs</code> should return the set-theoretic product of the list <code class="code">xs</code> with
    itself. That is, for each <code class="code">x,y</code> in <code class="code">xs</code>, the pair <code class="code">(x,y)</code> should occur in
    <code class="code">all_pairs xs</code>.<br>
</div>
</body></html>